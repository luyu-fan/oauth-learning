# OAuth 2.0

## 概要

### 什么是

OAuth 2.0 是一种行业标准的身份授权协议，本身也可以实现为一种授权框架，它能够使得第三方应用借助利用资源服务器提供的资源拥有者和资源之间的一系列授权交互动作，得到对应资源http服务的访问资格。

那么在具体的实际应用场景中则是，通过某一个授权中心，可以利用这个授权中心提供的身份信息完成其他应用（第三方）的身份验证从而达到服务的目的，而不需要额外的注册、密码提供等操作，整个过程都是比较安全的。除了应用在多个应用平台之间的身份授权之外，还可以广泛应用于系统内部各个子模块（例如微服务调用的上下游）的业务授权和身份验证。

### 为什么

使用Open Auth的原因就是因为传统的CS身份验证系统会存在较大的问题，客户端在向服务端请求服务的时候需要提供自己的身份验证信息去验证身份以访问受保护的资源，绝大多数都是通过密码验证的，也就是说用户的密码信息必须要和这些第三方及其客户端共享（第三方的概念是相对的，即应用之间可以互为第三方），这样就会有很多的潜在问题所在：

- 第三方应用必须保存用户的身份信息，从比较抽象的层面来看这一步是冗余的。
- 第三方应用必须同样实现身份验证逻辑，例如支持密码验证等。
- 在基于直接身份验证等情况下，第三方服务对用户受保护资源等访问是没有任何期限、权限等限制的。
- 传统情况下用户也无法单独撤回对某一个第三方应用的访问权限。而且大多数时候要修改密码完成。
- 第三方应用、保护数据此时已经显示地和用户提供身份信息耦合起来。

OAuth框架提供了一个授权层来解决上述问题，通过客户端向用户以及资源服务器发送请求（用户在资源服务器上完成授权动作）获得访问token达到第三方应用及客户端与用户之间的解耦。

### 怎么用

## 详细协议

在OAuth 2.0协议对应的[RFC文档 6749](https://datatracker.ietf.org/doc/html/rfc6749)中，主要会有以下几个主题：

### 核心部分

1. 协议中角色的定义

协议定义了四种角色：

- **资源拥有者(用户)**：能够进行对保护数据进行交互授权的实体，大多数情况下就是用户本身。

- **资源服务器**：保存了实体对应保护数据的地方，以及验证token完成对受保护资源的提供。

- **客户端**：代表了资源拥有者（代理）以及其授权的受保护资源请求发起方。可以是任何平台以及任何形式的需要请求受保护数据的应用。

- **授权服务器**： 提供用户授权交互过程服务以及在成功后对第三方客户端颁发token的服务。大多数情况下授权服务器和资源服务器是同一个。


2. 协议流

![协议流](http://wilo-common-bucket.oss-cn-hangzhou.aliyuncs.com/notes/oauth2-protocol/oauth2flow.png#pic_center)

显然，整个授权过程由第三方客户端发起，为用户提供授权交互流程的入口，具体授权过程依然需要借助授权服务器。（可以认为是在这一步重定向到授权服务器， TODO 怎么将用户转入到授权服务器？怎么告知授权服务器自己作为客户端到身份？）

第二步，授权服务器返回授权码（TODO 怎么将授权码交给第三方客户端？），代表资源拥有者已经授权可以访问受保护资源。返回的授权码是和请求访问授权的类型有关。

第三步，客户端在获取到用户的授权码之后，可以凭借此授权码访问授权服务器获取访问token，token里面会包含一些限制信息。

第四步，授权服务器在收到授权码之后会进行验证，通过之后会颁发访问token。

第五步，客户端凭借访问token去获取资源。

第六步，资源服务器验证access token是否通过，通过后返回资源数据。

3. 授权

所谓授权就是资源拥有者通过在资源授权服务器上的交互，以这种交互的形式授权客户端能够去申请访问资源，即获得访问token。
其中最核心基础也就是安全性最高的就是基于授权码的授权流程，除此之外还有使用资源拥有者账号密码、隐式授权以及客户端授权等多种形式。

- 授权码

授权码会借助授权服务器作为中间服务器在资源拥有者和第三方应用客户端之间完成多次重定向。客户端不会直接向授权服务器发起授权请求，而是以重定向的方式将资源拥有者定向到授权服务器的授权接口（一般通过用户代理，如果是web则可以理解为浏览器）。在授权服务器上用户完成授权动作之后，授权服务器会连同授权码一起将用户重新定向到第三方客户端，这样用户的验证信息便不会共享给第三方应用。

另外，授权码也能提供一些安全性，如果直接将access-token返回则很有可能暴露给其他实体。

- 隐式授权

隐式授权是对标准授权码形式的简化，主要是针对那些在用户代理中实现了的客户端，例如使用javascript等浏览器脚本语言。此时授权服务器便不会颁发授权码而是直接将访问token返回，因为没有使用任何授权码再次发起请求而是直接得到了访问token，因此被称之为隐式的。

隐式授权比较适合那种没有后端的应用，因而自然就会有一定的安全性问题，因为授权服务器不会进一步验证客户端，虽然在某些情况下也可以通过重定向去验证客户端再去颁发访问token，但没有本质上解决这个问题，访问token可以暴露给多个访问实体。

当然，隐式授权由于没有授权码这一步，自然在性能上有一定的优势，但会牺牲一定的安全性。

- 资源拥有者身份验证（账号密码形式）

如果第三方应用想要去访问受保护的资源，那么他以持有资源拥有者本身的身份信息来直接获取访问token的形式也是可以的（代替授权码），这就相当于第三方应用客户端再次代理用户进行了登陆验证。显然只有在非常信任这个第三方应用的时候才是可取的，它可以共享资源拥有者的身份信息。

值得注意的是，这种授权方式虽然要求提供身份信息，但是第三方应用可以不用保存这些信息（如果恶意保存呢？），仅仅作为一次性请求访问token使用。

- 客户端验证

当客户端同时又是资源拥有者时，或者受保护的资源完全可以由客户端来控制时，客户端身份验证就可以用作一种授权类型。

4. 访问TOKEN

访问token就是用于访问受保护资源的身份凭证字符串，代表着身份标识，它指明访问的指定域和生命周期，并且收到资源服务器和授权服务器的控制。

**访问token提供了一个抽象的身份验证层，使得身份验证以及资源访问更具有限制性**。同时也避免了资源服务器去理解不同的授权方法。同时，访问token可以有不同的形式、结构以及实用的方法，这取决于资源服务器如何配置。

#### 刷新token

刷新token是用于在访问token快失效或者过期时来获取新的访问token时的身份凭证（或者是用于更新更窄的访问域），同样也需要资源服务器颁发。颁发一个刷新token对于资源服务器来说是比较谨慎的，因为在颁发这个token的同时也要包含后续对访问token的颁发。当然，刷新token仅仅用于授权服务器的验证，而且在每次获取到访问token的时候就会获得刷新token，以后只需要利用这个刷新token去更新访问token即可。

![TokensFlow](http://wilo-common-bucket.oss-cn-hangzhou.aliyuncs.com/notes/oauth2-protocol/tokensflow.png#pic_center)

5. TLS版本

OAuth也会使用TLS，但是版本并不固定，随时间以及安全政策而变，使用最多的依然是1.0和1.2。OAuth的实现应该充分考虑到对运输层安全协议的支持。

6. HTTP重定向

客户端和授权服务器都会用到重定向，在不同的阶段将资源拥有者定向到不同的目标。大多数情况下使用的都是临时重定向302。

7. 互操作性

OAuth仅仅是一个授权框架，自身虽然也提供了预定义的安全属性，但是对于一些其他的组件则需要自由组合，这也是可扩展性的体现。例如客户端注册、服务器兼容、服务发现等。

## 第三方客户端的注册

在使用OAuth协议框架之前，很显然需要注册一个发起请求的客户端，这个交互过程并不包括在协议流程内，因此需要提前准备（这个也是扩展性和自由组合的特点）。

不管是采用user-agent的形式还是注册中心的形式，一个客户端必须要指明以下信息：

1. 指明客户端类型。

2. 提供客户端的回调重定向URIs。

3. 其他授权服务器所必须要知道的基本信息。（依赖于授权服务器而定）


### 客户端类型

OAuth根据授权的安全性（能够维持他们客户端验证信息的保密性）定义了两种客户端类型：

- 保密的：客户端能够安全保密地持有他们的身份凭证，即客户端一般在服务器上实现，能够安全严格受限地访问客户端身份凭证。
- 公开的：与之相反，例如那些即是客户端又是资源持有者或者是基于web脚本的客户端。

在分布式的情况下，如果一个客户端有两种不同类型的子实体，即客户端是多个子实体的集合。如果授权服务器不支持此类的客户端那么就应该将这些子实体给拆分为一个个独立的客户端实体。

客户端实体可以大致划分为以下三类：
- web应用：保密的。一般运行在web服务器上，一般可以通过web页面的形式引导用户完成授权动作。所有的客户端信息连同各类token都不会被暴露出去。
- 用户代理的应用（user-agent-based):公开的。一般为内嵌于web浏览器中（用户代理）的脚本客户端。由资源拥有者直接操作。数据容易被访问和暴露。
- 原生应用：公开的。同样由资源拥有者使用。一般安装在资源拥有者的设备上，数据仅由资源拥有者访问，但是那些身份凭证信息能够被提取，或者由同设备上的其他应用提供。

### 客户端标识

由授权服务器给客户端颁发一个客户端标识字符串。客户端标识并不是密钥，它仅仅是一个唯一性标识，和资源拥有者一起向资源服务器发起请求。标识的大小应该由授权服务器决定。

### 客户端验证

如果客户端是保密的，客户端和授权服务器就会建立一个合适的客户端授权方法，授权服务器可以接受任何满足他安全要求的客户端请求。实际上保密的客户端大多数都是通过密码、密钥机制来完成身份凭证的。

授权服务器也可以和公开的客户端建立客户端验证方法，但是授权服务器一定不能依赖或完全信任这种验证能够起到标识客户端的目的。

1. 客户端密码

密码是最常见的一种身份验证形式，客户端拥有账户和密码便可以使用http基础的身份验证模式去验证。
客户端标识使用`application/x-www-form-urlencoded`这种编码方式来进行http请求。此时对应的授权服务器至少要支持这种basic的身份验证方式。

此时体现在http头中：

`Authorization: Basic xxxxxxxxxxx-client-identifier-xxxxxxxxxxxx`.

另外在请求体中也可以包含以下的参数:

`client_id: (required), 代表了client的标识ID。`

`client_secret: (required), 代表了client的密钥或口令。`

在使用密码验证的时候，授权服务器必要要求使用TLS来防止授权方法被攻击。

2. 其他形式授权

除了基本的basic身份验证之外，还可以支持任何合适的http身份验证机制。此时授权服务器有责任必须定义一个客户端标识和验证模式之间的映射。

3. 注销客户端

就是一般的注销接口，只不过是发生在授权服务器上而已。

## 协议终端（endpoint: 终端、进程）

文档中指出，授权过程会有两个服务终端以及至少一个客户终端。

- 授权终端：用来和客户端完成授权过程以及用户端的重定向工作。

- Token终端：客户端在持有身份验证的情况下去获取访问码。

- 客户终端：主要指的是重定向终端，授权服务器会将授权码以用户代理重定向的方式返回给客户端。

终端的类型和数目都是不固定的，都可以根据实际场景灵活配置。

### 授权终端

核心目的：**用于和资源拥有者交互以使得资源拥有者能够授权给第三方应用去获取对应受保护的数据。**

处理逻辑：

1. 验证资源拥有者身份的合法性。例如密码等身份凭证。

2. 重定向的请求中必须包括`application/x-www-form-urlencoeded`的请求格式。除了主体是授权服务器提供的URI之外，还必须要加入额外的参数。

3. **由于向授权服务器发送的重定向请求中会带有身份验证信息以及在响应头中也会带有身份信息，所以必须以TLS连接的形式发送请求。**

4. 授权服务器至少要接受简单的RESTful请求。

5. 客户端和授权服务端对请求参数的处理也有一定的要求，即没有值的字段做缺省忽略处理以及无法识别的字段必须忽略。请求和响应中的字段不能超过一次。

#### 响应类型

在请求时必须要指明请求的数据类型，即是授权码还是token。是必须项。如果是多个可以扩展的请求类型则可以使用空格分割。

如果请求时不满足格式或者类型要求，则授权服务器要返回一个`Error`。

#### 重定向终端

在完成和资源拥有者的交互之后，授权服务器就会将用户代理（user-agent）重定向回客户端（对于前后端没有分离的项目来说，显然就是后端提供的一个URI），这个也被称之为回调地址，实在客户端注册阶段就已经确定并登记的。

回调的重定向操作必须是一个完整的URI, 可以包括`application/x-www-form-urlencoed`格式的数据。

> 当客户端请求code以及token的时候。授权服务器应该要求这是一个TLS连接的请求，尤其是在一个公开的网络上时，但是文档说明**客户端具备建立TLS连接的能力并不是强制的**，原因就是对于大多数客户端开发者而言为他们的客户端请求建立TLS连接还是有一定的困难（获取客户端证书）。在没有建立TLS连接的情况下，授权服务器有责任警告资源拥有者这一情况。

- 授权服务器必须要求客户端注册他们的回调URI,这包括了客户端身份信息以及授权类型。当然可以注册多个回调URI。（在没有注册的情况下，客户端可以通过`state`字段来使得自定义每一个请求的回调）。在注册时不能确定回调的情况下，授权服务器应该要求其说明URI的模式，授权以及路径模板，表明那些是可以动态改变的部分。

在缺少注册的情况下，授权服务器很可能被攻击作为一个公开的重定向终端。

- 动态配置。如果需要动态地提供回调URI以灵活满足某些需求，则需要在请求的`request_uri`字段里面指明。显然授权服务器应该具备URI比较和匹配的能力。

- 不可用终端。如果授权请求有问题，授权服务器应该向资源拥有者告知错误而不是将其重定向到某个URI。

- 终端内容。这一点其实就说明了怎样来组织URI回调。一般情况下，回调重定向的URI的实际内容大多是可以被用户代理（web浏览器）渲染的页面，此时页面中的脚本实际上是可以拿到身份验证信息的。因此需要确保安全性。

通常的做法就是客户端返回的重定向页面里不应该包括任何第三方脚本，最好的方案就是先将这些必要的身份验证信息给提取出来，保持这个重定向页面的简洁（或空白），然后再次重定向到具体的不带有身份验证信息的业务页面去做，实际上这么做也能做到解耦。

### Token终端

token终端显然就是客户端获取访问终端token的地方，除了隐式类型之外，token终端在其它的三种类型里都应该有。

在客户端获取token时，除了要保证请求格式外，还必须要使用**POST**动作。显然，客户端请求时必须被验证。验证的好处在于强制要求两种token始终绑定在一起，以及在重定向过程中的简要安全性，以及兼顾令牌刷新的安全性和简洁性。

一般情况下，客户端会使用`client_id`请求参数来标识自身身份，利用这个身份标识可以完成客户端与各种数据的绑定，避免混乱。

### 访问token范围(scope)

授权和token端允许客户端通过`scope`字段来指定访问的范围，值可以是有空格分隔的字符串，这些值的组成部分是由授权服务器提供的，同样授权终端也可以通过`scope`来指定颁发的访问token的范围。

授权服务器或许部分或者全部忽略scope中的数据，这取决于服务端的政策。如果客户端提出的范围和服务端配置的不同，则服务端会在响应中告知客户端正确的`scope`。如果客户端的请求中忽略了这个字段，服务端就应该按照默认缺省值处理或者是按报错处理。

## 获取访问token

### 授权码授权

授权码会用于获取访问和刷新token，并且针对可信的客户端有了一定的优化。**授权过程的本质是重定向流**，因此OAuth协议中需要要求用户代理（web页面）必须提供和资源拥有者进行交互的能力。

授权获取访问码的过程如下：
![GrantProcess](http://wilo-common-bucket.oss-cn-hangzhou.aliyuncs.com/notes/oauth2-protocol/codeinteraction.png)

其中ABC三个部分实际上因为资源拥有者的参与会被分为多个部分。

1. 客户端通过将资源拥有者引导重定向至授权终端，即授权服务器提供的交互页面。在这个重定向URI中会包括客户端的ID, 请求范围，以及状态等等信息，发送给授权服务器。

2. 授权服务器开始授权交互流程。

3. 如果资源拥有者已经授权了访问，授权服务器会将用户代理重定向回客户端提供的回调URI（考虑standalone以及前后端分离的情况应该怎么处理）。

4. 客户端接受到授权码之后准备从授权服务器哪里获取访问token。

5. 授权服务器对客户端的验证通过之后，确保授权码以及重定向地址匹配，返回刷新token和访问token。

下面是主要关键动作的Http请求：

#### 授权请求

客户端在构建授权请求的时候，所遵循的请求格式如下：

+ 必须是`application/x-www-form-urlencoced`格式。
+ 必须字段`client_id`，用来标识的客户端。
+ 必须字段`response_type`，表示期待获取的内容是什么，在获取授权码时必须是code。
+ 可选字段`redirection_uri`，在授权成功之后引导资源拥有者的回调地址。
+ 可选字段`scope`，访问的范围。由授权服务器决定。
+ 可选字段`state`，客户端实用化一个唯一的表示用来维护请求和回调之间的唯一性。（解决无状态的问题）。授权服务器会在将资源拥有者重定向返回的时候包括这个值。**这个值一般会被在跨站点访问时使用**。

例如一个客户端请求授权码：
```
GET /authorize?response_type=code&client_id=s6BhdRkqt3&state=xyz
        &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1
Host: server.example.com
```

##### 授权响应

如果经过交互之后，资源拥有者可以授权将授权码返回给用户的回调函数，那么响应需要满足以下的格式：

1. 格式要求：`application/x-www-form-urlencoded`。
2. 必须项`code`表示授权码。授权码应该有时间限制，而且是一次性使用。否则，授权服务器将会拒绝请求，而且有可能会收回已经颁发的所有相关token。授权码和客户端的回调URI是绑定在一起的。
3. 必须项`state`如果在客户端的请求中出现时，他一定会在响应中出现。
多余的字段应该被忽略。

一个可能的授权响应如下：
![AuthorizationResponse](http://wilo-common-bucket.oss-cn-hangzhou.aliyuncs.com/notes/oauth2-protocol/authorization%20response.png#pic_center)

##### 错误响应

如果请求失败（可能由验证失败、参数错误、客户端id错误、 缺失URI等或缺失等种种错误导致的）授权服务器应该通知资源拥有者这个错误，而不是自动地重定向处理。在拥有者明确拒绝客户端的情况下，授权服务器会返回一个包含了error信息的响应。

`x-www-form-urlencoded`格式的响应中必须包含一个`error`的字段，这个字段的具体值包含了以下几种中的一种：

|code|含义|
|:----:|:----:|
|invalid_request|请求中缺失了一个必须的参数，包括未验证通过的情况、超过一次的参数或者其他不合法的情况|
|unauthorized_client|客户端没有被授权使用该方法来获取授权码，可能是访问方法不对|
|access_denied|资源拥有者拒绝客户端访问这个资源|
|unsupported_response_type|服务端不支持使用该方法获取授权码|
|invalid_scope|错误或者不合适的访问域|
|server_erroe|授权服务器发生了内部错误，但是由于是重定向的形式，则必须要通过特定的错误码告知客户端服务器内部出现了问题。|
|temporarily_unavailable|授权服务器临时不可访问，可能是由于临时错误或者是维护等|

除此之外还包括的字段：

`error_description`可选项，人眼可读的描述文本，用于辅助客户端开发者定位、理解和解决错误。
`error_uri`可选项，利用一个web页面来详细告知客户端开发者的错误信息。
`state`和请求相对应，当请求携带的时候响应也必然会携带，用于和客户端进行状态同步。

```
HTTP/1.1 302 Found
   Location: https://client.example.com/cb?error=access_denied&state=xyz
```

#### 访问Token请求

在获取token的请求中必须包含以下字段:

`grant_type`必须项，标识授权的类型，一般是授权码还是隐式授权还是用户代理的方式，即那四种方式之一。

`code`必须项，代表了授权码。
`redirect_uri`必须项、表示重定向地址。
`client_id`必须项，代表了客户端的ID。

```
POST /token HTTP/1.1
     Host: server.example.com
     Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
     Content-Type: application/x-www-form-urlencoded

     grant_type=authorization_code&code=SplxlOBeZQQYbYS6WxSbIA
     &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb
```

授权服务器必须保证:

- 要求客户端提供身份凭证并验证。
- 确保授权码和客户端绑定的一致性。
- 确保重定向uri的合法性和一致性。

#### 访问Token响应

如果请求合法且验证通过，授权服务器就会颁发合适的访问token，显然如果验证失败等就会返回错误响应。一个成功的响应如下：
```html
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
"access_token":"2YotnFZFEjr1zCsicMWpAA",
"token_type":"example",
"expires_in":3600,
"refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
"example_parameter":"example_value"
}
```
其中有几个重要的点需要注意，第一个是响应返回的格式是json类型，而且禁用缓存。在返回的json数据中会告知token、类型以及过期的时间。

### 隐式授权

隐式授权通常用于那些“公开的客户端（浏览器端的js脚本程序）”进行授权，并进行了一定的优化。隐式授权不会有客户端验证这个步骤，仅仅依赖于授权服务器和
资源拥有者交互本身。

**隐式授权的最大不同之处在于在请求授权码的那一步操作时，如果授权成功就直接返回访问token，即编码在重定向URI中，因此有可能会被暴露**。

隐式授权的整个流程如下：

![Implict](http://wilo-common-bucket.oss-cn-hangzhou.aliyuncs.com/notes/oauth2-protocol/implicitgrant.png#pic_center)

- 以客户端将用户重定向到授权交互页面为开始，此类客户端也会包含客户端标识信息，请求范围，状态和重定向的URI以供授权服务器返回。

- 授权服务器根据用户的交互决定是否会授权（用户交互操作同意或者是拒绝）。

- 在用户同意的情况下，将用户代理重定向返回回调uri, 包含token（仅仅访问token）。

- 此时用户代理也会根据重定向来对web上的资源发起请求，此时用户代理就会在本地保留这些信息。

- 用户代理（浏览器）在本地执行客户端提供的脚本，脚本会从中抽取访问token。

- 用户代理将访问token传递给客户端。

个人理解：

此时所谓的客户端就是一个js脚本代码，这个脚本代码由于是基于浏览器的公开的，因此和用户代理部分是有一点模糊边界的。但总之利用访问token获取数据就是客户端部分。而对重定向URI中token的提取虽然也是脚本但它属于用户代理部分。

### 资源拥有者密码授权

密码授权适用于资源拥有者完全信任第三方客户端，服务端对这种请求形式应该特别注意。另外，它也用可以使用Http Basic这种简单的授权方式来将客户端存储的用户身份信息转换为token。

![PWDFlow](http://wilo-common-bucket.oss-cn-hangzhou.aliyuncs.com/notes/oauth2-protocol/resourcepwd.png#pic_center)

整个流程如下：

-  资源拥有者分享自己的身份信息，主要是密码等。

- 客户端携带身份细信息请求访问token。当发起请求的时候，客户端直接在授权服务器哪里进行验证。

- 授权服务器对客户端携带的用户身份进行验证。验证通过之后就直接颁发token。

在请求访问token的时候，依然使用之前相同的格式，并且必须包含以下字段：

`grant_type`授权类型必须项，必须写作`password`。
`username`用户名必须项。
`password`密码必须项。
`scope`范围可选项。

请求格式和之前的差别不大。返回token信息格式与数据也基本相同。

需要注意的是，客户端是拿着用户的身份信息来访问资源拥有者的数据，但是客户端自身也需要被验证，这个也是那个basic的作用。只有客户端程序合法，资源拥有者身份信息合法才是真正的合法。

### 客户端身份授权

客户端也可以仅仅通过客户端自身的身份信息来获取访问token，当然前提是用户资源已经提前得到了某些授权。

![ClientCredentials](http://wilo-common-bucket.oss-cn-hangzhou.aliyuncs.com/notes/oauth2-protocol/clientcredentials.png#pic_center)

客户端授权相对比较简单，因为它仅仅需要自身的身份验证即可，因此在验证通过之后就可以得到访问token。也因此，客户端会有自己的身份验证机制，从而
授权码获取那个步骤可以直接省略。

#### 获取访问Token

因为直接通过客户端身份验证，所以只需要确保`grant_type`这个字段为`client_credentials`，以及合适的访问范围即可获取到访问token。在验证通过的情况下，授权服务器就会返回`application/json`类型的响应。并且不允许缓存。

### 其他可扩展的授权

将需要访问的URI的绝对地址形式作为授权类型，然后去访问获取得到访问token。并且也可添加任何额外的且必要的参数。另外在扩展授权的情况下可能会使用到SAM标记语言。此时在验证通过的情况下，可以同时返回访问token和刷新token。

## 颁发访问Token

在请求验证通过的情况下，一般可以直接返回访问token或者是刷新token，但是刷新token往往是根据授权的类型来决定的，是一个可选项。

### 成功的响应

一个成功的响应主要会包含下列关键字段：

`access_token`必须项。
`token_type`必须项，代表了token的类型。
`expires_in`表明token过期的时间。推荐字段。
`refresh_token`刷新token。
`scope`可选项。

响应采用的都是标准的json格式。

**所有的包含了token的响应必须有`Cache-Control`字段，而且必须要设置为`no-store`。显然如果客户端无法识别的字段直接忽略。一个成功的响应如下：

```html
     HTTP/1.1 200 OK
     Content-Type: application/json;charset=UTF-8
     Cache-Control: no-store
     Pragma: no-cache

     {
       "access_token":"2YotnFZFEjr1zCsicMWpAA",
       "token_type":"example",
       "expires_in":3600,
       "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
       "example_parameter":"example_value"
     }
```

### 错误的响应

在请求没有通过验证的情况下，授权服务器会返回一个400响应，并且会包含以下字段：

`error`必须项，一个简短的错误码来告知出现了什么错误，一般是`invalid_request`、`invalid_client`、`invalid_grant`、`unauthorized_client`、`unsupported_grant_type`以及`invalid_scope`这几种。

`error_description`是一个详细说明。
`error_uri`则是一个错误的详细说明页面。

基本上格式都是统一的。

```
     HTTP/1.1 400 Bad Request
     Content-Type: application/json;charset=UTF-8
     Cache-Control: no-store
     Pragma: no-cache

     {
       "error":"invalid_request"
     }
```

## 刷新Token

在授权码类型方式中，如果授权服务器给客户端颁发了一个刷新token，那么客户端在快到期时就可以利用这个刷新token来获取新的访问token。在一个新的请求之中必须包括以下字段：

`grant_type`必须项且必须为`refresh_token`。
`refresh_token`必须项且是颁发给客户端的。
`scope`可选项，必须是原始范围中的一个子集。

同样，请求依然是`x-www-form-urlencoded`格式。

在进行token刷新请求时，必须要求客户端携带有自己的身份凭证。一般即采用Basic授权即可，然后就是需要确认这个刷新token的合法性以及是否和客户端绑定在一起。

授权服务器在颁发一个新的token时，有可能也可以颁发一个新的刷新token，此时客户端显然就只能丢弃旧的token。授权服务器可以收回对客户端的已经颁发的某些权限。值得注意的是，当颁发新的刷新token时，需要和请求中的保持一致。

## 访问受保护资源

## 可扩展性

## 本地应用

## 安全性考虑
