# OAuth 2.0

## 概要

### 什么是

OAuth 2.0 是一种行业标准的身份授权协议，本身也可以实现为一种授权框架，它能够使得第三方应用借助利用资源服务器提供的资源拥有者和资源之间的一系列授权交互动作，得到对应资源http服务的访问资格。

那么在具体的实际应用场景中则是，通过某一个授权中心，可以利用这个授权中心提供的身份信息完成其他应用（第三方）的身份验证从而达到服务的目的，而不需要额外的注册、密码提供等操作，整个过程都是比较安全的。除了应用在多个应用平台之间的身份授权之外，还可以广泛应用于系统内部各个子模块（例如微服务调用的上下游）的业务授权和身份验证。

### 为什么

使用Open Auth的原因就是因为传统的CS身份验证系统会存在较大的问题，客户端在向服务端请求服务的时候需要提供自己的身份验证信息去验证身份以访问受保护的资源，绝大多数都是通过密码验证的，也就是说用户的密码信息必须要和这些第三方及其客户端共享（第三方的概念是相对的，即应用之间可以互为第三方），这样就会有很多的潜在问题所在：

- 第三方应用必须保存用户的身份信息，从比较抽象的层面来看这一步是冗余的。
- 第三方应用必须同样实现身份验证逻辑，例如支持密码验证等。
- 在基于直接身份验证等情况下，第三方服务对用户受保护资源等访问是没有任何期限、权限等限制的。
- 传统情况下用户也无法单独撤回对某一个第三方应用的访问权限。而且大多数时候要修改密码完成。
- 第三方应用、保护数据此时已经显示地和用户提供身份信息耦合起来。

OAuth框架提供了一个授权层来解决上述问题，通过客户端向用户以及资源服务器发送请求（用户在资源服务器上完成授权动作）获得访问token达到第三方应用及客户端与用户之间的解耦。

### 怎么用

## 详细协议

在OAuth 2.0协议对应的[RFC文档 6749](https://datatracker.ietf.org/doc/html/rfc6749)中，主要会有以下几个主题：

### 核心部分

1. 协议中角色的定义

协议定义了四种角色：

- **资源拥有者(用户)**：能够进行对保护数据进行交互授权的实体，大多数情况下就是用户本身。

- **资源服务器**：保存了实体对应保护数据的地方，以及验证token完成对受保护资源的提供。

- **客户端**：代表了资源拥有者（代理）以及其授权的受保护资源请求发起方。可以是任何平台以及任何形式的需要请求受保护数据的应用。

- **授权服务器**： 提供用户授权交互过程服务以及在成功后对第三方客户端颁发token的服务。大多数情况下授权服务器和资源服务器是同一个。


2. 协议流

![协议流](http://wilo-common-bucket.oss-cn-hangzhou.aliyuncs.com/notes/oauth2-protocol/oauth2flow.png#pic_center)

显然，整个授权过程由第三方客户端发起，为用户提供授权交互流程的入口，具体授权过程依然需要借助授权服务器。（可以认为是在这一步重定向到授权服务器， TODO 怎么将用户转入到授权服务器？怎么告知授权服务器自己作为客户端到身份？）

第二步，授权服务器返回授权码（TODO 怎么将授权码交给第三方客户端？），代表资源拥有者已经授权可以访问受保护资源。返回的授权码是和请求访问授权的类型有关。

第三步，客户端在获取到用户的授权码之后，可以凭借此授权码访问授权服务器获取访问token，token里面会包含一些限制信息。

第四步，授权服务器在收到授权码之后会进行验证，通过之后会颁发访问token。

第五步，客户端凭借访问token去获取资源。

第六步，资源服务器验证access token是否通过，通过后返回资源数据。

3. 授权

所谓授权就是资源拥有者通过在资源授权服务器上的交互，以这种交互的形式授权客户端能够去申请访问资源，即获得访问token。
其中最核心基础也就是安全性最高的就是基于授权码的授权流程，除此之外还有使用资源拥有者账号密码、隐式授权以及客户端授权等多种形式。

- 授权码

授权码会借助授权服务器作为中间服务器在资源拥有者和第三方应用客户端之间完成多次重定向。客户端不会直接向授权服务器发起授权请求，而是以重定向的方式将资源拥有者定向到授权服务器的授权接口（一般通过用户代理，如果是web则可以理解为浏览器）。在授权服务器上用户完成授权动作之后，授权服务器会连同授权码一起将用户重新定向到第三方客户端，这样用户的验证信息便不会共享给第三方应用。

另外，授权码也能提供一些安全性，如果直接将access-token返回则很有可能暴露给其他实体。

- 隐式授权

隐式授权是对标准授权码形式的简化，主要是针对那些在用户代理中实现了的客户端，例如使用javascript等浏览器脚本语言。此时授权服务器便不会颁发授权码而是直接将访问token返回，因为没有使用任何授权码再次发起请求而是直接得到了访问token，因此被称之为隐式的。

隐式授权比较适合那种没有后端的应用，因而自然就会有一定的安全性问题，因为授权服务器不会进一步验证客户端，虽然在某些情况下也可以通过重定向去验证客户端再去颁发访问token，但没有本质上解决这个问题，访问token可以暴露给多个访问实体。

当然，隐式授权由于没有授权码这一步，自然在性能上有一定的优势，但会牺牲一定的安全性。

- 资源拥有者身份验证（账号密码形式）

如果第三方应用想要去访问受保护的资源，那么他以持有资源拥有者本身的身份信息来直接获取访问token的形式也是可以的（代替授权码），这就相当于第三方应用客户端再次代理用户进行了登陆验证。显然只有在非常信任这个第三方应用的时候才是可取的，它可以共享资源拥有者的身份信息。

值得注意的是，这种授权方式虽然要求提供身份信息，但是第三方应用可以不用保存这些信息（如果恶意保存呢？），仅仅作为一次性请求访问token使用。

- 客户端验证

当客户端同时又是资源拥有者时，或者受保护的资源完全可以由客户端来控制时，客户端身份验证就可以用作一种授权类型。

4. 访问TOKEN

访问token就是用于访问受保护资源的身份凭证字符串，代表着身份标识，它指明访问的指定域和生命周期，并且收到资源服务器和授权服务器的控制。

**访问token提供了一个抽象的身份验证层，使得身份验证以及资源访问更具有限制性**。同时也避免了资源服务器去理解不同的授权方法。同时，访问token可以有不同的形式、结构以及实用的方法，这取决于资源服务器如何配置。

#### 刷新token

刷新token是用于在访问token快失效或者过期时来获取新的访问token时的身份凭证（或者是用于更新更窄的访问域），同样也需要资源服务器颁发。颁发一个刷新token对于资源服务器来说是比较谨慎的，因为在颁发这个token的同时也要包含后续对访问token的颁发。当然，刷新token仅仅用于授权服务器的验证，而且在每次获取到访问token的时候就会获得刷新token，以后只需要利用这个刷新token去更新访问token即可。

![TokensFlow](http://wilo-common-bucket.oss-cn-hangzhou.aliyuncs.com/notes/oauth2-protocol/tokensflow.png#pic_center)

5. TLS版本

OAuth也会使用TLS，但是版本并不固定，随时间以及安全政策而变，使用最多的依然是1.0和1.2。OAuth的实现应该充分考虑到对运输层安全协议的支持。

6. HTTP重定向

客户端和授权服务器都会用到重定向，在不同的阶段将资源拥有者定向到不同的目标。大多数情况下使用的都是临时重定向302。

7. 互操作性

OAuth仅仅是一个授权框架，自身虽然也提供了预定义的安全属性，但是对于一些其他的组件则需要自由组合，这也是可扩展性的体现。例如客户端注册、服务器兼容、服务发现等。

## 第三方客户端的注册

在使用OAuth协议框架之前，很显然需要注册一个发起请求的客户端，这个交互过程并不包括在协议流程内，因此需要提前准备（这个也是扩展性和自由组合的特点）。

不管是采用user-agent的形式还是注册中心的形式，一个客户端必须要指明以下信息：

1. 指明客户端类型。

2. 提供客户端的回调重定向URIs。

3. 其他授权服务器所必须要知道的基本信息。（依赖于授权服务器而定）


### 客户端类型

OAuth根据授权的安全性（能够维持他们客户端验证信息的保密性）定义了两种客户端类型：

- 保密的：客户端能够安全保密地持有他们的身份凭证，即客户端一般在服务器上实现，能够安全严格受限地访问客户端身份凭证。
- 公开的：与之相反，例如那些即是客户端又是资源持有者或者是基于web脚本的客户端。

在分布式的情况下，如果一个客户端有两种不同类型的子实体，即客户端是多个子实体的集合。如果授权服务器不支持此类的客户端那么就应该将这些子实体给拆分为一个个独立的客户端实体。

客户端实体可以大致划分为以下三类：
- web应用：保密的。一般运行在web服务器上，一般可以通过web页面的形式引导用户完成授权动作。所有的客户端信息连同各类token都不会被暴露出去。
- 用户代理的应用（user-agent-based):公开的。一般为内嵌于web浏览器中（用户代理）的脚本客户端。由资源拥有者直接操作。数据容易被访问和暴露。
- 原生应用：公开的。同样由资源拥有者使用。一般安装在资源拥有者的设备上，数据仅由资源拥有者访问，但是那些身份凭证信息能够被提取，或者由同设备上的其他应用提供。

### 客户端标识

由授权服务器给客户端颁发一个客户端标识字符串。客户端标识并不是密钥，它仅仅是一个唯一性标识，和资源拥有者一起向资源服务器发起请求。标识的大小应该由授权服务器决定。

### 客户端验证

如果客户端是保密的，客户端和授权服务器就会建立一个合适的客户端授权方法，授权服务器可以接受任何满足他安全要求的客户端请求。实际上保密的客户端大多数都是通过密码、密钥机制来完成身份凭证的。

授权服务器也可以和公开的客户端建立客户端验证方法，但是授权服务器一定不能依赖或完全信任这种验证能够起到标识客户端的目的。

1. 客户端密码

密码是最常见的一种身份验证形式，客户端拥有账户和密码便可以使用http基础的身份验证模式去验证。
客户端标识使用`application/x-www-form-urlencoded`这种编码方式来进行http请求。此时对应的授权服务器至少要支持这种basic的身份验证方式。

此时体现在http头中：

`Authorization: Basic xxxxxxxxxxx-client-identifier-xxxxxxxxxxxx`.

另外在请求体中也可以包含以下的参数:

`client_id: (required), 代表了client的标识ID。`

`client_secret: (required), 代表了client的密钥或口令。`

在使用密码验证的时候，授权服务器必要要求使用TLS来防止授权方法被攻击。

2. 其他形式授权

除了基本的basic身份验证之外，还可以支持任何合适的http身份验证机制。此时授权服务器有责任必须定义一个客户端标识和验证模式之间的映射。

3. 注销客户端

就是一般的注销接口，只不过是发生在授权服务器上而已。

## 协议的终端

## 获取授权认证

## 颁发访问token

## 刷新访问token

## 访问受保护资源

## 可扩展性

## 本地应用

## 安全性考虑
