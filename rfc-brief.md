# OAuth 2.0

## 概要

### 什么是

OAuth 2.0 是一种行业标准的身份授权协议，本身也可以实现为一种授权框架，它能够使得第三方应用借助利用资源服务器提供的资源拥有者和资源之间的一系列授权交互动作，得到对应资源http服务的访问资格。

那么在具体的实际应用场景中则是，通过某一个授权中心，可以利用这个授权中心提供的身份信息完成其他应用（第三方）的身份验证从而达到服务的目的，而不需要额外的注册、密码提供等操作，整个过程都是比较安全的。除了应用在多个应用平台之间的身份授权之外，还可以广泛应用于系统内部各个子模块（例如微服务调用的上下游）的业务授权和身份验证。

### 为什么

使用Open Auth的原因就是因为传统的CS身份验证系统会存在较大的问题，客户端在向服务端请求服务的时候需要提供自己的身份验证信息去验证身份以访问受保护的资源，绝大多数都是通过密码验证的，也就是说用户的密码信息必须要和这些第三方及其客户端共享（第三方的概念是相对的，即应用之间可以互为第三方），这样就会有很多的潜在问题所在：

- 第三方应用必须保存用户的身份信息，从比较抽象的层面来看这一步是冗余的。
- 第三方应用必须同样实现身份验证逻辑，例如支持密码验证等。
- 在基于直接身份验证等情况下，第三方服务对用户受保护资源等访问是没有任何期限、权限等限制的。
- 传统情况下用户也无法单独撤回对某一个第三方应用的访问权限。而且大多数时候要修改密码完成。
- 第三方应用、保护数据此时已经显示地和用户提供身份信息耦合起来。

OAuth框架提供了一个授权层来解决上述问题，通过客户端向用户以及资源服务器发送请求（用户在资源服务器上完成授权动作）获得访问token达到第三方应用及客户端与用户之间的解耦。

### 怎么用


## 详细协议

在OAuth 2.0协议对应的[RFC文档 6749](https://datatracker.ietf.org/doc/html/rfc6749)中，主要会有以下几个主题：

### 核心部分

1. 协议中角色的定义

协议定义了四种角色：

- **资源拥有者(用户)**：能够进行对保护数据进行交互授权的实体，大多数情况下就是用户本身。

- **资源服务器**：保存了实体对应保护数据的地方，以及验证token完成对受保护资源的提供。

- **客户端**：代表了资源拥有者（代理）以及其授权的受保护资源请求发起方。可以是任何平台以及任何形式的需要请求受保护数据的应用。

- **授权服务器**： 提供用户授权交互过程服务以及在成功后对第三方客户端颁发token的服务。大多数情况下授权服务器和资源服务器是同一个。


2. 协议流

![协议流](http://wilo-common-bucket.oss-cn-hangzhou.aliyuncs.com/notes/oauth2-protocol/oauth2flow.png#pic_center)

显然，整个授权过程由第三方客户端发起，为用户提供授权交互流程的入口，具体授权过程依然需要借助授权服务器。（可以认为是在这一步重定向到授权服务器， TODO 怎么将用户转入到授权服务器？怎么告知授权服务器自己作为客户端到身份？）

第二步，授权服务器返回授权码（TODO 怎么将授权码交给第三方客户端？），代表资源拥有者已经授权可以访问受保护资源。返回的授权码是和请求访问授权的类型有关。

第三步，客户端在获取到用户的授权码之后，可以凭借此授权码访问授权服务器获取访问token，token里面会包含一些限制信息。

第四步，授权服务器在收到授权码之后会进行验证，通过之后会颁发访问token。

第五步，客户端凭借访问token去获取资源。

第六步，资源服务器验证access token是否通过，通过后返回资源数据。

3. 授权

所谓授权就是资源拥有者通过在资源授权服务器上的交互，以这种交互的形式授权客户端能够去申请访问资源，即获得访问token。
其中最核心基础也就是安全性最高的就是基于授权码的授权流程，除此之外还有使用资源拥有者账号密码、隐式授权以及客户端授权等多种形式。

- 授权码

授权码会借助授权服务器作为中间服务器在资源拥有者和第三方应用客户端之间完成多次重定向。客户端不会直接向授权服务器发起授权请求，而是以重定向的方式将资源拥有者定向到授权服务器的授权接口（一般通过用户代理，如果是web则可以理解为浏览器）。在授权服务器上用户完成授权动作之后，授权服务器会连同授权码一起将用户重新定向到第三方客户端，这样用户的验证信息便不会共享给第三方应用。

另外，授权码也能提供一些安全性，如果直接将access-token返回则很有可能暴露给其他实体。

- 隐式授权

隐式授权是对标准授权码形式的简化，主要是针对那些在用户代理中实现了的客户端，例如使用javascript等浏览器脚本语言。此时授权服务器便不会颁发授权码而是直接将访问token返回，因为没有使用任何授权码再次发起请求而是直接得到了访问token，因此被称之为隐式的。

隐式授权比较适合那种没有后端的应用，因而自然就会有一定的安全性问题，因为授权服务器不会进一步验证客户端，虽然在某些情况下也可以通过重定向去验证客户端再去颁发访问token，但没有本质上解决这个问题，访问token可以暴露给多个访问实体。

当然，隐式授权由于没有授权码这一步，自然在性能上有一定的优势，但会牺牲一定的安全性。

- 资源拥有者身份验证（账号密码形式）

如果第三方应用想要去访问受保护的资源，那么他以持有资源拥有者本身的身份信息来直接获取访问token的形式也是可以的（代替授权码），这就相当于第三方应用客户端再次代理用户进行了登陆验证。显然只有在非常信任这个第三方应用的时候才是可取的，它可以共享资源拥有者的身份信息。

值得注意的是，这种授权方式虽然要求提供身份信息，但是第三方应用可以不用保存这些信息（如果恶意保存呢？），仅仅作为一次性请求访问token使用。

- 客户端验证

当客户端同时又是资源拥有者时，或者受保护的资源完全可以由客户端来控制时，客户端身份验证就可以用作一种授权类型。

4. 访问TOKEN

访问token就是用于访问受保护资源的身份凭证字符串，代表着身份标识，它指明访问的指定域和生命周期，并且收到资源服务器和授权服务器的控制。

**访问token提供了一个抽象的身份验证层，使得身份验证以及资源访问更具有限制性**。同时也避免了资源服务器去理解不同的授权方法。同时，访问token可以有不同的形式、结构以及实用的方法，这取决于资源服务器如何配置。

#### 刷新token

刷新token是用于在访问token快失效或者过期时来获取新的访问token时的身份凭证（或者是用于更新更窄的访问域），同样也需要资源服务器颁发。颁发一个刷新token对于资源服务器来说是比较谨慎的，因为在颁发这个token的同时也要包含后续对访问token的颁发。当然，刷新token仅仅用于授权服务器的验证，而且在每次获取到访问token的时候就会获得刷新token，以后只需要利用这个刷新token去更新访问token即可。

![TokensFlow](http://wilo-common-bucket.oss-cn-hangzhou.aliyuncs.com/notes/oauth2-protocol/tokensflow.png#pic_center)

5. TLS版本

OAuth也会使用TLS，但是版本并不固定，随时间以及安全政策而变，使用最多的依然是1.0和1.2。OAuth的实现应该充分考虑到对运输层安全协议的支持。

6. HTTP重定向

客户端和授权服务器都会用到重定向，在不同的阶段将资源拥有者定向到不同的目标。大多数情况下使用的都是临时重定向302。

7. 互操作性

OAuth仅仅是一个授权框架，自身虽然也提供了预定义的安全属性，但是对于一些其他的组件则需要自由组合，这也是可扩展性的体现。例如客户端注册、服务器兼容、服务发现等。


### 第三方客户端的注册

### 协议的终端

### 获取授权认证

### 颁发访问token

### 刷新访问token

### 访问受保护资源

### 可扩展性

## 本地应用

### 安全性考虑
