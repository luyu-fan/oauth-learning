# OAuth 2.0

## 概要

### 什么是

OAuth 2.0 是一种行业标准的身份授权协议，本身也可以实现为一种授权框架，它能够使得第三方应用借助利用资源服务器提供的资源拥有者和资源之间的一系列授权交互动作，得到对应资源http服务的访问资格。

那么在具体的实际应用场景中则是，通过某一个授权中心，可以利用这个授权中心提供的身份信息完成其他应用（第三方）的身份验证从而达到服务的目的，而不需要额外的注册、密码提供等操作，整个过程都是比较安全的。除了应用在多个应用平台之间的身份授权之外，还可以广泛应用于系统内部各个子模块（例如微服务调用的上下游）的业务授权和身份验证。

### 为什么

使用Open Auth的原因就是因为传统的CS身份验证系统会存在较大的问题，客户端在向服务端请求服务的时候需要提供自己的身份验证信息去验证身份以访问受保护的资源，绝大多数都是通过密码验证的，也就是说用户的密码信息必须要和这些第三方及其客户端共享（第三方的概念是相对的，即应用之间可以互为第三方），这样就会有很多的潜在问题所在：

- 第三方应用必须保存用户的身份信息，从比较抽象的层面来看这一步是冗余的。
- 第三方应用必须同样实现身份验证逻辑，例如支持密码验证等。
- 在基于直接身份验证等情况下，第三方服务对用户受保护资源等访问是没有任何期限、权限等限制的。
- 传统情况下用户也无法单独撤回对某一个第三方应用的访问权限。而且大多数时候要修改密码完成。
- 第三方应用、保护数据此时已经显示地和用户提供身份信息耦合起来。

OAuth框架提供了一个授权层来解决上述问题，通过客户端向用户以及资源服务器发送请求（用户在资源服务器上完成授权动作）获得访问token达到第三方应用及客户端与用户之间的解耦。

### 怎么用

## 详细协议

在OAuth 2.0协议对应的[RFC文档 6749](https://datatracker.ietf.org/doc/html/rfc6749)中，主要会有以下几个主题：

### 核心部分

1. 协议中角色的定义

协议定义了四种角色：

- **资源拥有者(用户)**：能够进行对保护数据进行交互授权的实体，大多数情况下就是用户本身。

- **资源服务器**：保存了实体对应保护数据的地方，以及验证token完成对受保护资源的提供。

- **客户端**：代表了资源拥有者（代理）以及其授权的受保护资源请求发起方。可以是任何平台以及任何形式的需要请求受保护数据的应用。

- **授权服务器**： 提供用户授权交互过程服务以及在成功后对第三方客户端颁发token的服务。大多数情况下授权服务器和资源服务器是同一个。


2. 协议流

![协议流](http://wilo-common-bucket.oss-cn-hangzhou.aliyuncs.com/notes/oauth2-protocol/oauth2flow.png#pic_center)

显然，整个授权过程由第三方客户端发起，为用户提供授权交互流程的入口，具体授权过程依然需要借助授权服务器。（可以认为是在这一步重定向到授权服务器， TODO 怎么将用户转入到授权服务器？怎么告知授权服务器自己作为客户端到身份？）

第二步，授权服务器返回授权码（TODO 怎么将授权码交给第三方客户端？），代表资源拥有者已经授权可以访问受保护资源。返回的授权码是和请求访问授权的类型有关。

第三步，客户端在获取到用户的授权码之后，可以凭借此授权码访问授权服务器获取访问token，token里面会包含一些限制信息。

第四步，授权服务器在收到授权码之后会进行验证，通过之后会颁发访问token。

第五步，客户端凭借访问token去获取资源。

第六步，资源服务器验证access token是否通过，通过后返回资源数据。

3. 授权

所谓授权就是资源拥有者通过在资源授权服务器上的交互，以这种交互的形式授权客户端能够去申请访问资源，即获得访问token。
其中最核心基础也就是安全性最高的就是基于授权码的授权流程，除此之外还有使用资源拥有者账号密码、隐式授权以及客户端授权等多种形式。

- 授权码

授权码会借助授权服务器作为中间服务器在资源拥有者和第三方应用客户端之间完成多次重定向。客户端不会直接向授权服务器发起授权请求，而是以重定向的方式将资源拥有者定向到授权服务器的授权接口（一般通过用户代理，如果是web则可以理解为浏览器）。在授权服务器上用户完成授权动作之后，授权服务器会连同授权码一起将用户重新定向到第三方客户端，这样用户的验证信息便不会共享给第三方应用。

另外，授权码也能提供一些安全性，如果直接将access-token返回则很有可能暴露给其他实体。

- 隐式授权

隐式授权是对标准授权码形式的简化，主要是针对那些在用户代理中实现了的客户端，例如使用javascript等浏览器脚本语言。此时授权服务器便不会颁发授权码而是直接将访问token返回，因为没有使用任何授权码再次发起请求而是直接得到了访问token，因此被称之为隐式的。

隐式授权比较适合那种没有后端的应用，因而自然就会有一定的安全性问题，因为授权服务器不会进一步验证客户端，虽然在某些情况下也可以通过重定向去验证客户端再去颁发访问token，但没有本质上解决这个问题，访问token可以暴露给多个访问实体。

当然，隐式授权由于没有授权码这一步，自然在性能上有一定的优势，但会牺牲一定的安全性。

- 资源拥有者身份验证（账号密码形式）

如果第三方应用想要去访问受保护的资源，那么他以持有资源拥有者本身的身份信息来直接获取访问token的形式也是可以的（代替授权码），这就相当于第三方应用客户端再次代理用户进行了登陆验证。显然只有在非常信任这个第三方应用的时候才是可取的，它可以共享资源拥有者的身份信息。

值得注意的是，这种授权方式虽然要求提供身份信息，但是第三方应用可以不用保存这些信息（如果恶意保存呢？），仅仅作为一次性请求访问token使用。

- 客户端验证

当客户端同时又是资源拥有者时，或者受保护的资源完全可以由客户端来控制时，客户端身份验证就可以用作一种授权类型。

4. 访问TOKEN

访问token就是用于访问受保护资源的身份凭证字符串，代表着身份标识，它指明访问的指定域和生命周期，并且收到资源服务器和授权服务器的控制。

**访问token提供了一个抽象的身份验证层，使得身份验证以及资源访问更具有限制性**。同时也避免了资源服务器去理解不同的授权方法。同时，访问token可以有不同的形式、结构以及实用的方法，这取决于资源服务器如何配置。

#### 刷新token

刷新token是用于在访问token快失效或者过期时来获取新的访问token时的身份凭证（或者是用于更新更窄的访问域），同样也需要资源服务器颁发。颁发一个刷新token对于资源服务器来说是比较谨慎的，因为在颁发这个token的同时也要包含后续对访问token的颁发。当然，刷新token仅仅用于授权服务器的验证，而且在每次获取到访问token的时候就会获得刷新token，以后只需要利用这个刷新token去更新访问token即可。

![TokensFlow](http://wilo-common-bucket.oss-cn-hangzhou.aliyuncs.com/notes/oauth2-protocol/tokensflow.png#pic_center)

5. TLS版本

OAuth也会使用TLS，但是版本并不固定，随时间以及安全政策而变，使用最多的依然是1.0和1.2。OAuth的实现应该充分考虑到对运输层安全协议的支持。

6. HTTP重定向

客户端和授权服务器都会用到重定向，在不同的阶段将资源拥有者定向到不同的目标。大多数情况下使用的都是临时重定向302。

7. 互操作性

OAuth仅仅是一个授权框架，自身虽然也提供了预定义的安全属性，但是对于一些其他的组件则需要自由组合，这也是可扩展性的体现。例如客户端注册、服务器兼容、服务发现等。

## 第三方客户端的注册

在使用OAuth协议框架之前，很显然需要注册一个发起请求的客户端，这个交互过程并不包括在协议流程内，因此需要提前准备（这个也是扩展性和自由组合的特点）。

不管是采用user-agent的形式还是注册中心的形式，一个客户端必须要指明以下信息：

1. 指明客户端类型。

2. 提供客户端的回调重定向URIs。

3. 其他授权服务器所必须要知道的基本信息。（依赖于授权服务器而定）


### 客户端类型

OAuth根据授权的安全性（能够维持他们客户端验证信息的保密性）定义了两种客户端类型：

- 保密的：客户端能够安全保密地持有他们的身份凭证，即客户端一般在服务器上实现，能够安全严格受限地访问客户端身份凭证。
- 公开的：与之相反，例如那些即是客户端又是资源持有者或者是基于web脚本的客户端。

在分布式的情况下，如果一个客户端有两种不同类型的子实体，即客户端是多个子实体的集合。如果授权服务器不支持此类的客户端那么就应该将这些子实体给拆分为一个个独立的客户端实体。

客户端实体可以大致划分为以下三类：
- web应用：保密的。一般运行在web服务器上，一般可以通过web页面的形式引导用户完成授权动作。所有的客户端信息连同各类token都不会被暴露出去。
- 用户代理的应用（user-agent-based):公开的。一般为内嵌于web浏览器中（用户代理）的脚本客户端。由资源拥有者直接操作。数据容易被访问和暴露。
- 原生应用：公开的。同样由资源拥有者使用。一般安装在资源拥有者的设备上，数据仅由资源拥有者访问，但是那些身份凭证信息能够被提取，或者由同设备上的其他应用提供。

### 客户端标识

由授权服务器给客户端颁发一个客户端标识字符串。客户端标识并不是密钥，它仅仅是一个唯一性标识，和资源拥有者一起向资源服务器发起请求。标识的大小应该由授权服务器决定。

### 客户端验证

如果客户端是保密的，客户端和授权服务器就会建立一个合适的客户端授权方法，授权服务器可以接受任何满足他安全要求的客户端请求。实际上保密的客户端大多数都是通过密码、密钥机制来完成身份凭证的。

授权服务器也可以和公开的客户端建立客户端验证方法，但是授权服务器一定不能依赖或完全信任这种验证能够起到标识客户端的目的。

1. 客户端密码

密码是最常见的一种身份验证形式，客户端拥有账户和密码便可以使用http基础的身份验证模式去验证。
客户端标识使用`application/x-www-form-urlencoded`这种编码方式来进行http请求。此时对应的授权服务器至少要支持这种basic的身份验证方式。

此时体现在http头中：

`Authorization: Basic xxxxxxxxxxx-client-identifier-xxxxxxxxxxxx`.

另外在请求体中也可以包含以下的参数:

`client_id: (required), 代表了client的标识ID。`

`client_secret: (required), 代表了client的密钥或口令。`

在使用密码验证的时候，授权服务器必要要求使用TLS来防止授权方法被攻击。

2. 其他形式授权

除了基本的basic身份验证之外，还可以支持任何合适的http身份验证机制。此时授权服务器有责任必须定义一个客户端标识和验证模式之间的映射。

3. 注销客户端

就是一般的注销接口，只不过是发生在授权服务器上而已。

## 协议终端（endpoint: 终端、进程）

文档中指出，授权过程会有两个服务终端以及至少一个客户终端。

- 授权终端：用来和客户端完成授权过程以及用户端的重定向工作。

- Token终端：客户端在持有身份验证的情况下去获取访问码。

- 客户终端：主要指的是重定向终端，授权服务器会将授权码以用户代理重定向的方式返回给客户端。

终端的类型和数目都是不固定的，都可以根据实际场景灵活配置。

### 授权终端

核心目的：**用于和资源拥有者交互以使得资源拥有者能够授权给第三方应用去获取对应受保护的数据。**

处理逻辑：

1. 验证资源拥有者身份的合法性。例如密码等身份凭证。

2. 重定向的请求中必须包括`application/x-www-form-urlencoeded`的请求格式。除了主体是授权服务器提供的URI之外，还必须要加入额外的参数。

3. **由于向授权服务器发送的重定向请求中会带有身份验证信息以及在响应头中也会带有身份信息，所以必须以TLS连接的形式发送请求。**

4. 授权服务器至少要接受简单的RESTful请求。

5. 客户端和授权服务端对请求参数的处理也有一定的要求，即没有值的字段做缺省忽略处理以及无法识别的字段必须忽略。请求和响应中的字段不能超过一次。

#### 响应类型

在请求时必须要指明请求的数据类型，即是授权码还是token。是必须项。如果是多个可以扩展的请求类型则可以使用空格分割。

如果请求时不满足格式或者类型要求，则授权服务器要返回一个`Error`。

#### 重定向终端

在完成和资源拥有者的交互之后，授权服务器就会将用户代理（user-agent）重定向回客户端（对于前后端没有分离的项目来说，显然就是后端提供的一个URI），这个也被称之为回调地址，实在客户端注册阶段就已经确定并登记的。

回调的重定向操作必须是一个完整的URI, 可以包括`application/x-www-form-urlencoed`格式的数据。

> 当客户端请求code以及token的时候。授权服务器应该要求这是一个TLS连接的请求，尤其是在一个公开的网络上时，但是文档说明**客户端具备建立TLS连接的能力并不是强制的**，原因就是对于大多数客户端开发者而言为他们的客户端请求建立TLS连接还是有一定的困难（获取客户端证书）。在没有建立TLS连接的情况下，授权服务器有责任警告资源拥有者这一情况。

- 授权服务器必须要求客户端注册他们的回调URI,这包括了客户端身份信息以及授权类型。当然可以注册多个回调URI。（在没有注册的情况下，客户端可以通过`state`字段来使得自定义每一个请求的回调）。在注册时不能确定回调的情况下，授权服务器应该要求其说明URI的模式，授权以及路径模板，表明那些是可以动态改变的部分。

在缺少注册的情况下，授权服务器很可能被攻击作为一个公开的重定向终端。

- 动态配置。如果需要动态地提供回调URI以灵活满足某些需求，则需要在请求的`request_uri`字段里面指明。显然授权服务器应该具备URI比较和匹配的能力。

- 不可用终端。如果授权请求有问题，授权服务器应该向资源拥有者告知错误而不是将其重定向到某个URI。

- 终端内容。这一点其实就说明了怎样来组织URI回调。一般情况下，回调重定向的URI的实际内容大多是可以被用户代理（web浏览器）渲染的页面，此时页面中的脚本实际上是可以拿到身份验证信息的。因此需要确保安全性。

通常的做法就是客户端返回的重定向页面里不应该包括任何第三方脚本，最好的方案就是先将这些必要的身份验证信息给提取出来，保持这个重定向页面的简洁（或空白），然后再次重定向到具体的不带有身份验证信息的业务页面去做，实际上这么做也能做到解耦。

### Token终端

token终端显然就是客户端获取访问终端token的地方，除了隐式类型之外，token终端在其它的三种类型里都应该有。

在客户端获取token时，除了要保证请求格式外，还必须要使用**POST**动作。显然，客户端请求时必须被验证。验证的好处在于强制要求两种token始终绑定在一起，以及在重定向过程中的简要安全性，以及兼顾令牌刷新的安全性和简洁性。

一般情况下，客户端会使用`client_id`请求参数来标识自身身份，利用这个身份标识可以完成客户端与各种数据的绑定，避免混乱。

### 访问token范围(scope)

授权和token端允许客户端通过`scope`字段来指定访问的范围，值可以是有空格分隔的字符串，这些值的组成部分是由授权服务器提供的，同样授权终端也可以通过`scope`来指定颁发的访问token的范围。

授权服务器或许部分或者全部忽略scope中的数据，这取决于服务端的政策。如果客户端提出的范围和服务端配置的不同，则服务端会在响应中告知客户端正确的`scope`。如果客户端的请求中忽略了这个字段，服务端就应该按照默认缺省值处理或者是按报错处理。

## 获取访问token

### 授权码授权

授权码会用于获取访问和刷新token，并且针对可信的客户端有了一定的优化。**授权过程的本质是重定向流**，因此OAuth协议中需要要求用户代理（web页面）必须提供和资源拥有者进行交互的能力。

授权获取访问码的过程如下：
![GrantProcess](http://wilo-common-bucket.oss-cn-hangzhou.aliyuncs.com/notes/oauth2-protocol/codeinteraction.png)

其中ABC三个部分实际上因为资源拥有者的参与会被分为多个部分。

1. 客户端通过将资源拥有者引导重定向至授权终端，即授权服务器提供的交互页面。在这个重定向URI中会包括客户端的ID, 请求范围，以及状态等等信息，发送给授权服务器。

2. 授权服务器开始授权交互流程。

3. 如果资源拥有者已经授权了访问，授权服务器会将用户代理重定向回客户端提供的回调URI（考虑standalone以及前后端分离的情况应该怎么处理）。

4. 客户端接受到授权码之后准备从授权服务器哪里获取访问token。

5. 授权服务器对客户端的验证通过之后，确保授权码以及重定向地址匹配，返回刷新token和访问token。

下面是主要关键动作的Http请求：

1. 授权请求

客户端在构建授权请求的时候，所遵循的请求格式如下：

+ 必须是`application/x-www-form-urlencoced`格式。
+ 必须字段`client_id`，用来标识的客户端。
+ 必须字段`response_type`，表示期待获取的内容是什么，在获取授权码时必须是code。
+ 可选字段`redirection_uri`，在授权成功之后引导资源拥有者的回调地址。
+ 可选字段`scope`，访问的范围。由授权服务器决定。
+ 可选字段`state`，客户端实用化一个唯一的表示用来维护请求和回调之间的唯一性。（解决无状态的问题）。授权服务器会在将资源拥有者重定向返回的时候包括这个值。**这个值一般会被在跨站点访问时使用**。

例如一个客户端请求授权码：
```
GET /authorize?response_type=code&client_id=s6BhdRkqt3&state=xyz
        &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1
Host: server.example.com
```

## 刷新访问token

## 访问受保护资源

## 可扩展性

## 本地应用

## 安全性考虑
